name: E2E Tests

on:
  pull_request:
    branches: [main]
    paths:
      - "src/**"
      - "e2e/**"
      - "bin/**"
      - "package.json"
      - "pnpm-lock.yaml"
      - ".github/workflows/e2e-tests.yml"
  push:
    branches: [main, feature/e2e-testing-framework]
  workflow_dispatch:
    inputs:
      verbose:
        description: "Run tests in verbose mode"
        required: false
        default: "false"
        type: choice
        options:
          - "true"
          - "false"

concurrency:
  group: e2e-${{ github.ref }}
  cancel-in-progress: true

jobs:
  e2e:
    name: E2E Tests
    runs-on: ubuntu-latest
    timeout-minutes: 30

    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: saleor
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      saleor:
        image: ghcr.io/saleor/saleor:3.20
        ports:
          - 8000:8000
        env:
          DATABASE_URL: postgresql://postgres:postgres@postgres:5432/saleor
          REDIS_URL: redis://redis:6379/0
          CELERY_BROKER_URL: redis://redis:6379/1
          SECRET_KEY: test-secret-key-for-e2e
          DEBUG: 'True'
          ALLOWED_HOSTS: '*'
          ALLOWED_CLIENT_HOSTS: '*'
          DEFAULT_FROM_EMAIL: admin@example.com
          ENABLE_ACCOUNT_CONFIRMATION_BY_EMAIL: 'False'
          ENABLE_SSL: 'False'
          ENABLE_DEBUG_TOOLBAR: 'False'
          MAX_CHECKOUT_LINE_QUANTITY: '50'
          PLAYGROUND_ENABLED: 'True'
        options: >-
          --health-cmd "curl -f http://localhost:8000/health/ || curl -f http://localhost:8000/ || exit 1"
          --health-interval 15s
          --health-timeout 10s
          --health-retries 40
          --health-start-period 120s

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          run_install: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: ".nvmrc"
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build CLI
        run: pnpm build

      - name: Wait for Saleor service to be ready
        run: |
          echo "üîç Checking Saleor service health..."
          
          # Wait up to 5 minutes for the service to be healthy
          for i in {1..60}; do
            if docker ps --filter "ancestor=ghcr.io/saleor/saleor:3.20" --format "table {{.ID}}\t{{.Status}}" | grep -q "healthy"; then
              echo "‚úÖ Saleor service is healthy"
              break
            elif docker ps --filter "ancestor=ghcr.io/saleor/saleor:3.20" --format "table {{.ID}}\t{{.Status}}" | grep -q "unhealthy"; then
              echo "‚ùå Saleor service is unhealthy"
              echo "üìù Container logs:"
              docker logs $(docker ps --filter "ancestor=ghcr.io/saleor/saleor:3.20" -q) --tail 50
              exit 1
            else
              echo "‚è≥ Waiting for Saleor service (attempt $i/60)..."
              sleep 5
            fi
          done
          
          # Final check
          if ! docker ps --filter "ancestor=ghcr.io/saleor/saleor:3.20" --format "table {{.ID}}\t{{.Status}}" | grep -q "healthy"; then
            echo "‚ùå Saleor service did not become healthy within 5 minutes"
            echo "üìù Final container logs:"
            docker logs $(docker ps --filter "ancestor=ghcr.io/saleor/saleor:3.20" -q) --tail 100
            exit 1
          fi

      - name: Initialize Saleor
        run: |
          SALEOR_CONTAINER_ID="${{ job.services.saleor.id }}"
          
          echo "üîß Running database migrations..."
          if ! docker exec $SALEOR_CONTAINER_ID python manage.py migrate --no-input; then
            echo "‚ùå Database migrations failed"
            docker logs $SALEOR_CONTAINER_ID --tail 50
            exit 1
          fi
          
          echo "üë§ Creating superuser..."
          if ! docker exec $SALEOR_CONTAINER_ID python manage.py shell -c "
            from django.contrib.auth import get_user_model
            User = get_user_model()
            if not User.objects.filter(email='admin@example.com').exists():
                User.objects.create_superuser(email='admin@example.com', password='admin123')
                print('Superuser created')
            else:
                print('Superuser exists')
          "; then
            echo "‚ùå Superuser creation failed"
            docker logs $SALEOR_CONTAINER_ID --tail 50
            exit 1
          fi
          
          echo "üß™ Testing GraphQL endpoint..."
          if ! curl -f http://localhost:8000/graphql/ \
            -X POST \
            -H "Content-Type: application/json" \
            -d '{"query":"{ shop { name } }"}' \
            --max-time 30; then
            echo "‚ùå GraphQL endpoint test failed"
            docker logs $SALEOR_CONTAINER_ID --tail 50
            exit 1
          fi
          
          echo "‚úÖ Saleor initialization complete"

      - name: Run quick smoke tests (no Docker required)
        if: github.event_name == 'pull_request'
        run: pnpm test:smoke:quick
        env:
          CI: true
          LOG_LEVEL: error

      - name: Run full smoke tests
        if: github.event_name == 'pull_request'
        run: pnpm test:smoke
        env:
          CI: true
          SALEOR_API_URL: http://localhost:8000/graphql/
          LOG_LEVEL: ${{ github.event.inputs.verbose == 'true' && 'debug' || 'error' }}
          VERBOSE: ${{ github.event.inputs.verbose }}

      - name: Run full E2E test suite
        if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
        run: pnpm test:e2e
        env:
          CI: true
          SALEOR_API_URL: http://localhost:8000/graphql/
          LOG_LEVEL: ${{ github.event.inputs.verbose == 'true' && 'debug' || 'error' }}
          VERBOSE: ${{ github.event.inputs.verbose }}

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-test-results-${{ github.run_id }}
          path: |
            e2e/test-results/
          retention-days: 7

      - name: Comment PR with test results
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // Try to read test results if they exist
            let testResults = 'üìä **E2E Test Results**\n\n';
            const resultsPath = 'e2e/test-results/e2e-results.json';
            
            try {
              if (fs.existsSync(resultsPath)) {
                const results = JSON.parse(fs.readFileSync(resultsPath, 'utf8'));
                const passed = results.numPassedTests || 0;
                const failed = results.numFailedTests || 0;
                const total = results.numTotalTests || 0;
                const duration = ((results.testResults?.[0]?.duration || 0) / 1000).toFixed(2);
                
                testResults += `‚úÖ Passed: ${passed}/${total}\n`;
                if (failed > 0) {
                  testResults += `‚ùå Failed: ${failed}\n`;
                }
                testResults += `‚è±Ô∏è Duration: ${duration}s\n`;
                
                if (failed > 0 && results.testResults) {
                  testResults += '\n**Failed Tests:**\n';
                  results.testResults.forEach(suite => {
                    suite.assertionResults?.filter(test => test.status === 'failed').forEach(test => {
                      testResults += `- ${test.title}\n`;
                    });
                  });
                }
              } else {
                testResults += '‚ö†Ô∏è Test results not found. Check the workflow logs for details.\n';
              }
            } catch (error) {
              testResults += `‚ö†Ô∏è Could not parse test results: ${error.message}\n`;
            }
            
            // Find and update or create comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && comment.body.includes('E2E Test Results')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: testResults
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: testResults
              });
            }

  e2e-required:
    name: E2E Tests Required
    runs-on: ubuntu-latest
    needs: [e2e]
    if: always()
    steps:
      - name: Check E2E test results
        run: |
          if [ "${{ needs.e2e.result }}" != "success" ]; then
            echo "‚ùå E2E tests failed or were cancelled"
            exit 1
          fi
          echo "‚úÖ All E2E tests passed"